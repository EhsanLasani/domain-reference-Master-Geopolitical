// Code generated by schema alignment tool. DO NOT EDIT.
package repositories

import (
	"context"
	"fmt"
	"time"
	"github.com/google/uuid"
	"gorm.io/gorm"
	"github.com/EhsanLasani/domain-reference-Master-Geopolitical/internal/xcut/cache"
	"github.com/EhsanLasani/domain-reference-Master-Geopolitical/internal/xcut/logging"
	models "github.com/EhsanLasani/domain-reference-Master-Geopolitical/data-access-layer/orm-odm-abstractions"
)

// AlignedCountryRepositoryInterface defines the contract for Country data access
type AlignedCountryRepositoryInterface interface {
	GetAllActiveCountries(ctx context.Context, tenantID string) ([]models.Country, error)
	GetByCode(ctx context.Context, tenantID, code string) (*models.Country, error)
	GetByID(ctx context.Context, tenantID string, id uuid.UUID) (*models.Country, error)
	Create(ctx context.Context, tenantID string, entity *models.Country) error
	Update(ctx context.Context, tenantID string, entity *models.Country) error
	Delete(ctx context.Context, tenantID string, code string) error
	BulkCreate(ctx context.Context, tenantID string, countries []models.Country) error
}

// AlignedCountryRepository implements AlignedCountryRepositoryInterface using GORM
type AlignedCountryRepository struct {
	db     *gorm.DB
	cache  cache.Cache
	logger logging.Logger
}

// NewAlignedCountryRepository creates a new GORM-based Country repository
func NewAlignedCountryRepository(db *gorm.DB, cache cache.Cache, logger logging.Logger) AlignedCountryRepositoryInterface {
	return &AlignedCountryRepository{
		db:     db,
		cache:  cache,
		logger: logger,
	}
}

// GetAllActiveCountries retrieves all active Countries
func (r *AlignedCountryRepository) GetAllActiveCountries(ctx context.Context, tenantID string) ([]models.Country, error) {
	var entities []models.Country
	err := r.db.WithContext(ctx).
		Where("is_active = ? AND is_deleted = ?", true, false).
		Order("country_name ASC").
		Find(&entities).Error
	
	if err != nil {
		return nil, fmt.Errorf("failed to query Countries: %w", err)
	}
	
	return entities, nil
}

// GetByCode retrieves a Country by country code
func (r *AlignedCountryRepository) GetByCode(ctx context.Context, tenantID, code string) (*models.Country, error) {
	var entity models.Country
	err := r.db.WithContext(ctx).
		Where("country_code = ? AND is_active = ? AND is_deleted = ?", code, true, false).
		First(&entity).Error
	
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to query Country by code: %w", err)
	}
	
	return &entity, nil
}

// GetByID retrieves a Country by ID
func (r *AlignedCountryRepository) GetByID(ctx context.Context, tenantID string, id uuid.UUID) (*models.Country, error) {
	var entity models.Country
	err := r.db.WithContext(ctx).
		Where("country_id = ? AND is_active = ? AND is_deleted = ?", id, true, false).
		First(&entity).Error
	
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to query Country by ID: %w", err)
	}
	
	return &entity, nil
}

// Create creates a new Country with full LASANI audit compliance
func (r *AlignedCountryRepository) Create(ctx context.Context, tenantID string, entity *models.Country) error {
	now := time.Now()
	
	// Set primary key and audit fields
	entity.CountryID = uuid.New()
	entity.CreatedAt = &now
	entity.UpdatedAt = &now
	entity.IsActive = true
	entity.IsDeleted = false
	entity.Version = 1
	entity.SourceSystem = "reference_master_geopolitical"
	
	// Set creation audit fields if available from context
	// entity.CreatedBy = getUserFromContext(ctx)
	// entity.CreatedIP = getIPFromContext(ctx)
	// entity.CreatedSession = getSessionFromContext(ctx)
	
	if err := r.db.WithContext(ctx).Create(entity).Error; err != nil {
		return fmt.Errorf("failed to create Country: %w", err)
	}
	
	return nil
}

// Update updates an existing Country with optimistic locking
func (r *AlignedCountryRepository) Update(ctx context.Context, tenantID string, entity *models.Country) error {
	now := time.Now()
	oldVersion := entity.Version
	
	// Update audit fields
	entity.UpdatedAt = &now
	entity.Version++
	
	// Set update audit fields if available from context
	// entity.UpdatedBy = getUserFromContext(ctx)
	// entity.UpdatedIP = getIPFromContext(ctx)
	// entity.UpdatedSession = getSessionFromContext(ctx)
	
	result := r.db.WithContext(ctx).
		Where("country_code = ? AND version = ?", entity.CountryCode, oldVersion).
		Updates(entity)
	
	if result.Error != nil {
		return fmt.Errorf("failed to update Country: %w", result.Error)
	}
	
	if result.RowsAffected == 0 {
		return fmt.Errorf("Country not found or version conflict")
	}
	
	return nil
}

// Delete soft deletes a Country
func (r *AlignedCountryRepository) Delete(ctx context.Context, tenantID string, code string) error {
	now := time.Now()
	
	result := r.db.WithContext(ctx).
		Where("country_code = ? AND is_deleted = ?", code, false).
		Updates(map[string]interface{}{
			"is_deleted":  true,
			"deleted_at":  now,
			"updated_at":  now,
			"version":     gorm.Expr("version + 1"),
			// "deleted_by": getUserFromContext(ctx),
			// "deleted_ip": getIPFromContext(ctx),
			// "deleted_session": getSessionFromContext(ctx),
		})
	
	if result.Error != nil {
		return fmt.Errorf("failed to delete Country: %w", result.Error)
	}
	
	if result.RowsAffected == 0 {
		return fmt.Errorf("Country not found")
	}
	
	return nil
}

// BulkCreate creates multiple countries in a transaction
func (r *AlignedCountryRepository) BulkCreate(ctx context.Context, tenantID string, countries []models.Country) error {
	return r.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		now := time.Now()
		
		for i := range countries {
			countries[i].CountryID = uuid.New()
			countries[i].CreatedAt = &now
			countries[i].UpdatedAt = &now
			countries[i].IsActive = true
			countries[i].IsDeleted = false
			countries[i].Version = 1
			countries[i].SourceSystem = "reference_master_geopolitical"
		}

		if err := tx.CreateInBatches(countries, 100).Error; err != nil {
			return fmt.Errorf("failed to bulk create countries: %w", err)
		}

		return nil
	})
}