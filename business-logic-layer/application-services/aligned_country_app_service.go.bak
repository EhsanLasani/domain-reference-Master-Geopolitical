// Code generated by schema alignment tool. DO NOT EDIT.
package applicationservices

import (
	"context"
	"fmt"
	"github.com/google/uuid"
	"github.com/EhsanLasani/domain-reference-Master-Geopolitical/internal/xcut/errors"
	"github.com/EhsanLasani/domain-reference-Master-Geopolitical/internal/xcut/logging"
	"github.com/EhsanLasani/domain-reference-Master-Geopolitical/internal/xcut/tracing"
	models "github.com/EhsanLasani/domain-reference-Master-Geopolitical/data-access-layer/orm-odm-abstractions"
	repositories "github.com/EhsanLasani/domain-reference-Master-Geopolitical/data-access-layer/repositories-daos"
)

// AlignedCountryAppService orchestrates country-related use cases with full schema alignment
type AlignedCountryAppService struct {
	countryRepo repositories.AlignedCountryRepositoryInterface
	logger      logging.Logger
	tracer      tracing.Tracer
}

// NewAlignedCountryAppService creates a new aligned country application service
func NewAlignedCountryAppService(
	countryRepo repositories.AlignedCountryRepositoryInterface,
	logger logging.Logger,
	tracer tracing.Tracer,
) *AlignedCountryAppService {
	return &AlignedCountryAppService{
		countryRepo: countryRepo,
		logger:      logger,
		tracer:      tracer,
	}
}

// GetAllCountries retrieves all active countries
func (s *AlignedCountryAppService) GetAllCountries(ctx context.Context, tenantID string) ([]models.Country, error) {
	ctx, span := s.tracer.StartSpan(ctx, "AlignedCountryAppService.GetAllCountries")
	defer span.End()

	s.logger.Info(ctx, "Retrieving all countries", 
		logging.Field{Key: "operation", Value: "get_all_countries"},
		logging.Field{Key: "tenant_id", Value: tenantID})

	countries, err := s.countryRepo.GetAllActiveCountries(ctx, tenantID)
	if err != nil {
		s.logger.Error(ctx, "Failed to retrieve countries", err,
			logging.Field{Key: "error", Value: err.Error()},
			logging.Field{Key: "tenant_id", Value: tenantID})
		return nil, errors.MapDatabaseError(err)
	}

	s.logger.Info(ctx, "Successfully retrieved countries",
		logging.Field{Key: "count", Value: len(countries)},
		logging.Field{Key: "tenant_id", Value: tenantID})

	return countries, nil
}

// CreateCountry creates a new country with full validation
func (s *AlignedCountryAppService) CreateCountry(ctx context.Context, tenantID string, country *models.Country) error {
	ctx, span := s.tracer.StartSpan(ctx, "AlignedCountryAppService.CreateCountry")
	defer span.End()

	s.logger.Info(ctx, "Creating new country",
		logging.Field{Key: "country_code", Value: country.CountryCode},
		logging.Field{Key: "country_name", Value: country.CountryName},
		logging.Field{Key: "operation", Value: "create_country"},
		logging.Field{Key: "tenant_id", Value: tenantID})

	// Business validation
	if err := s.validateCountryForCreation(country); err != nil {
		s.logger.Error(ctx, "Country validation failed", err,
			logging.Field{Key: "country_code", Value: country.CountryCode},
			logging.Field{Key: "validation_error", Value: err.Error()})
		return err
	}

	// Check for duplicate country code
	existing, err := s.countryRepo.GetByCode(ctx, tenantID, country.CountryCode)
	if err != nil {
		s.logger.Error(ctx, "Failed to check existing country", err,
			logging.Field{Key: "country_code", Value: country.CountryCode})
		return errors.MapDatabaseError(err)
	}
	
	if existing != nil {
		s.logger.Error(ctx, "Country code already exists", nil,
			logging.Field{Key: "country_code", Value: country.CountryCode},
			logging.Field{Key: "existing_id", Value: existing.CountryID})
		return errors.NewValidationError(fmt.Sprintf("Country code %s already exists", country.CountryCode))
	}

	// Create country
	err = s.countryRepo.Create(ctx, tenantID, country)
	if err != nil {
		s.logger.Error(ctx, "Failed to create country", err,
			logging.Field{Key: "country_code", Value: country.CountryCode})
		return errors.MapDatabaseError(err)
	}

	s.logger.Info(ctx, "Successfully created country",
		logging.Field{Key: "country_code", Value: country.CountryCode},
		logging.Field{Key: "country_id", Value: country.CountryID},
		logging.Field{Key: "tenant_id", Value: tenantID})

	return nil
}

// GetCountryByCode retrieves a country by its code
func (s *AlignedCountryAppService) GetCountryByCode(ctx context.Context, tenantID, countryCode string) (*models.Country, error) {
	ctx, span := s.tracer.StartSpan(ctx, "AlignedCountryAppService.GetCountryByCode")
	defer span.End()

	s.logger.Info(ctx, "Retrieving country by code",
		logging.Field{Key: "country_code", Value: countryCode},
		logging.Field{Key: "operation", Value: "get_country_by_code"},
		logging.Field{Key: "tenant_id", Value: tenantID})

	// Business validation
	if countryCode == "" {
		return nil, errors.NewValidationError("country code is required")
	}

	country, err := s.countryRepo.GetByCode(ctx, tenantID, countryCode)
	if err != nil {
		s.logger.Error(ctx, "Failed to retrieve country by code", err,
			logging.Field{Key: "country_code", Value: countryCode})
		return nil, errors.MapDatabaseError(err)
	}

	if country == nil {
		return nil, errors.NewNotFoundError(fmt.Sprintf("country with code %s", countryCode))
	}

	s.logger.Info(ctx, "Successfully retrieved country by code",
		logging.Field{Key: "country_code", Value: countryCode},
		logging.Field{Key: "country_id", Value: country.CountryID},
		logging.Field{Key: "tenant_id", Value: tenantID})

	return country, nil
}

// GetCountryByID retrieves a country by its ID
func (s *AlignedCountryAppService) GetCountryByID(ctx context.Context, tenantID string, id uuid.UUID) (*models.Country, error) {
	ctx, span := s.tracer.StartSpan(ctx, "AlignedCountryAppService.GetCountryByID")
	defer span.End()

	s.logger.Info(ctx, "Retrieving country by ID",
		logging.Field{Key: "country_id", Value: id},
		logging.Field{Key: "operation", Value: "get_country_by_id"},
		logging.Field{Key: "tenant_id", Value: tenantID})

	country, err := s.countryRepo.GetByID(ctx, tenantID, id)
	if err != nil {
		s.logger.Error(ctx, "Failed to retrieve country by ID", err,
			logging.Field{Key: "country_id", Value: id})
		return nil, errors.MapDatabaseError(err)
	}

	if country == nil {
		return nil, errors.NewNotFoundError(fmt.Sprintf("country with ID %s", id))
	}

	s.logger.Info(ctx, "Successfully retrieved country by ID",
		logging.Field{Key: "country_id", Value: id},
		logging.Field{Key: "country_code", Value: country.CountryCode},
		logging.Field{Key: "tenant_id", Value: tenantID})

	return country, nil
}

// UpdateCountry updates an existing country
func (s *AlignedCountryAppService) UpdateCountry(ctx context.Context, tenantID string, country *models.Country) error {
	ctx, span := s.tracer.StartSpan(ctx, "AlignedCountryAppService.UpdateCountry")
	defer span.End()

	s.logger.Info(ctx, "Updating country",
		logging.Field{Key: "country_code", Value: country.CountryCode},
		logging.Field{Key: "country_id", Value: country.CountryID},
		logging.Field{Key: "operation", Value: "update_country"},
		logging.Field{Key: "tenant_id", Value: tenantID})

	// Business validation
	if err := s.validateCountryForUpdate(country); err != nil {
		s.logger.Error(ctx, "Country validation failed", err,
			logging.Field{Key: "country_code", Value: country.CountryCode})
		return err
	}

	err := s.countryRepo.Update(ctx, tenantID, country)
	if err != nil {
		s.logger.Error(ctx, "Failed to update country", err,
			logging.Field{Key: "country_code", Value: country.CountryCode})
		return errors.MapDatabaseError(err)
	}

	s.logger.Info(ctx, "Successfully updated country",
		logging.Field{Key: "country_code", Value: country.CountryCode},
		logging.Field{Key: "country_id", Value: country.CountryID},
		logging.Field{Key: "tenant_id", Value: tenantID})

	return nil
}

// DeleteCountry soft deletes a country
func (s *AlignedCountryAppService) DeleteCountry(ctx context.Context, tenantID, countryCode string) error {
	ctx, span := s.tracer.StartSpan(ctx, "AlignedCountryAppService.DeleteCountry")
	defer span.End()

	s.logger.Info(ctx, "Deleting country",
		logging.Field{Key: "country_code", Value: countryCode},
		logging.Field{Key: "operation", Value: "delete_country"},
		logging.Field{Key: "tenant_id", Value: tenantID})

	// Business validation
	if countryCode == "" {
		return errors.NewValidationError("country code is required")
	}

	err := s.countryRepo.Delete(ctx, tenantID, countryCode)
	if err != nil {
		s.logger.Error(ctx, "Failed to delete country", err,
			logging.Field{Key: "country_code", Value: countryCode})
		return errors.MapDatabaseError(err)
	}

	s.logger.Info(ctx, "Successfully deleted country",
		logging.Field{Key: "country_code", Value: countryCode},
		logging.Field{Key: "tenant_id", Value: tenantID})

	return nil
}

// validateCountryForCreation validates country data for creation
func (s *AlignedCountryAppService) validateCountryForCreation(country *models.Country) error {
	if country.CountryCode == "" {
		return errors.NewValidationError("country code is required")
	}
	
	if len(country.CountryCode) != 2 {
		return errors.NewValidationError("country code must be exactly 2 characters")
	}
	
	if country.CountryName == "" {
		return errors.NewValidationError("country name is required")
	}
	
	if len(country.CountryName) > 100 {
		return errors.NewValidationError("country name must not exceed 100 characters")
	}
	
	// Validate ISO3 code if provided
	if country.ISO3Code != nil && len(*country.ISO3Code) != 3 {
		return errors.NewValidationError("ISO3 code must be exactly 3 characters")
	}
	
	// Validate continent code if provided
	if country.ContinentCode != nil {
		validContinents := []string{"AF", "AS", "EU", "NA", "SA", "OC", "AN"}
		valid := false
		for _, continent := range validContinents {
			if *country.ContinentCode == continent {
				valid = true
				break
			}
		}
		if !valid {
			return errors.NewValidationError("invalid continent code. Must be one of: AF, AS, EU, NA, SA, OC, AN")
		}
	}
	
	return nil
}

// validateCountryForUpdate validates country data for update
func (s *AlignedCountryAppService) validateCountryForUpdate(country *models.Country) error {
	if country.CountryID == uuid.Nil {
		return errors.NewValidationError("country ID is required for update")
	}
	
	return s.validateCountryForCreation(country)
}