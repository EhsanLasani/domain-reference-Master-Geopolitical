// Code generated by schema-to-code generator. DO NOT EDIT.
// Source: ref schema tables
// Generated: Auto-generated repository interfaces and implementations

package repositories

import (
	"context"
	"database/sql"
	"gorm.io/gorm"
	"github.com/google/uuid"
	"time"
)

// Auto-generated repository interfaces

// CountryRepositoryInterface defines operations for ref.countries table
type CountryRepositoryInterface interface {
	Create(ctx context.Context, country *Country) error
	GetByID(ctx context.Context, id uuid.UUID) (*Country, error)
	GetByCode(ctx context.Context, code string) (*Country, error)
	List(ctx context.Context, filter CountryFilter) ([]*Country, error)
	Update(ctx context.Context, country *Country) error
	Delete(ctx context.Context, id uuid.UUID, deletedBy uuid.UUID) error
	ExistsByCode(ctx context.Context, code string) (bool, error)
	GetActiveCount(ctx context.Context) (int, error)
}

// RegionRepositoryInterface defines operations for ref.regions table
type RegionRepositoryInterface interface {
	Create(ctx context.Context, region *Region) error
	GetByID(ctx context.Context, id uuid.UUID) (*Region, error)
	GetByCode(ctx context.Context, code string) (*Region, error)
	List(ctx context.Context, filter RegionFilter) ([]*Region, error)
	Update(ctx context.Context, region *Region) error
	Delete(ctx context.Context, id uuid.UUID, deletedBy uuid.UUID) error
	GetChildren(ctx context.Context, parentID uuid.UUID) ([]*Region, error)
}

// TimezoneRepositoryInterface defines operations for ref.timezones table
type TimezoneRepositoryInterface interface {
	Create(ctx context.Context, timezone *Timezone) error
	GetByID(ctx context.Context, id uuid.UUID) (*Timezone, error)
	GetByCode(ctx context.Context, code string) (*Timezone, error)
	List(ctx context.Context, filter TimezoneFilter) ([]*Timezone, error)
	Update(ctx context.Context, timezone *Timezone) error
	Delete(ctx context.Context, id uuid.UUID, deletedBy uuid.UUID) error
	GetByOffset(ctx context.Context, hours int16) ([]*Timezone, error)
}

// LanguageRepositoryInterface defines operations for ref.languages table
type LanguageRepositoryInterface interface {
	Create(ctx context.Context, language *Language) error
	GetByID(ctx context.Context, id uuid.UUID) (*Language, error)
	GetByCode(ctx context.Context, code string) (*Language, error)
	List(ctx context.Context, filter LanguageFilter) ([]*Language, error)
	Update(ctx context.Context, language *Language) error
	Delete(ctx context.Context, id uuid.UUID, deletedBy uuid.UUID) error
	GetByDirection(ctx context.Context, direction string) ([]*Language, error)
}

// Auto-generated filter structs

type CountryFilter struct {
	IsActive      *bool     `json:"is_active,omitempty"`
	CurrencyCode  *string   `json:"currency_code,omitempty"`
	ContinentCode *string   `json:"continent_code,omitempty"`
	CreatedAfter  *time.Time `json:"created_after,omitempty"`
	Limit         int       `json:"limit,omitempty"`
	Offset        int       `json:"offset,omitempty"`
}

type RegionFilter struct {
	IsActive     *bool      `json:"is_active,omitempty"`
	RegionType   *string    `json:"region_type,omitempty"`
	ParentID     *uuid.UUID `json:"parent_id,omitempty"`
	Limit        int        `json:"limit,omitempty"`
	Offset       int        `json:"offset,omitempty"`
}

type TimezoneFilter struct {
	IsActive     *bool  `json:"is_active,omitempty"`
	SupportsDST  *bool  `json:"supports_dst,omitempty"`
	OffsetHours  *int16 `json:"offset_hours,omitempty"`
	Limit        int    `json:"limit,omitempty"`
	Offset       int    `json:"offset,omitempty"`
}

type LanguageFilter struct {
	IsActive  *bool   `json:"is_active,omitempty"`
	Direction *string `json:"direction,omitempty"`
	Limit     int     `json:"limit,omitempty"`
	Offset    int     `json:"offset,omitempty"`
}

// Auto-generated GORM repository implementations

// CountryRepository implements CountryRepositoryInterface using GORM
type CountryRepository struct {
	db *gorm.DB
}

func NewCountryRepository(db *gorm.DB) CountryRepositoryInterface {
	return &CountryRepository{db: db}
}

func (r *CountryRepository) Create(ctx context.Context, country *Country) error {
	// Auto-populate LASANI audit fields
	now := time.Now()
	country.CreatedAt = &now
	country.UpdatedAt = &now
	
	return r.db.WithContext(ctx).Create(country).Error
}

func (r *CountryRepository) GetByID(ctx context.Context, id uuid.UUID) (*Country, error) {
	var country Country
	err := r.db.WithContext(ctx).
		Where("country_id = ? AND is_deleted = false", id).
		First(&country).Error
	
	if err != nil {
		return nil, err
	}
	return &country, nil
}

func (r *CountryRepository) GetByCode(ctx context.Context, code string) (*Country, error) {
	var country Country
	err := r.db.WithContext(ctx).
		Where("UPPER(country_code) = UPPER(?) AND is_deleted = false", code).
		First(&country).Error
	
	if err != nil {
		return nil, err
	}
	return &country, nil
}

func (r *CountryRepository) List(ctx context.Context, filter CountryFilter) ([]*Country, error) {
	query := r.db.WithContext(ctx).Where("is_deleted = false")
	
	// Apply filters
	if filter.IsActive != nil {
		query = query.Where("is_active = ?", *filter.IsActive)
	}
	if filter.CurrencyCode != nil {
		query = query.Where("currency_code = ?", *filter.CurrencyCode)
	}
	if filter.ContinentCode != nil {
		query = query.Where("continent_code = ?", *filter.ContinentCode)
	}
	if filter.CreatedAfter != nil {
		query = query.Where("created_at > ?", *filter.CreatedAfter)
	}
	
	// Apply pagination
	if filter.Limit > 0 {
		query = query.Limit(filter.Limit)
	}
	if filter.Offset > 0 {
		query = query.Offset(filter.Offset)
	}
	
	var countries []*Country
	err := query.Order("country_code").Find(&countries).Error
	return countries, err
}

func (r *CountryRepository) Update(ctx context.Context, country *Country) error {
	// Auto-populate LASANI audit fields
	now := time.Now()
	country.UpdatedAt = &now
	country.Version++
	
	return r.db.WithContext(ctx).
		Where("country_id = ? AND is_deleted = false", country.CountryID).
		Updates(country).Error
}

func (r *CountryRepository) Delete(ctx context.Context, id uuid.UUID, deletedBy uuid.UUID) error {
	now := time.Now()
	
	return r.db.WithContext(ctx).
		Model(&Country{}).
		Where("country_id = ? AND is_deleted = false", id).
		Updates(map[string]interface{}{
			"is_deleted": true,
			"is_active":  false,
			"deleted_at": now,
			"deleted_by": deletedBy,
			"updated_at": now,
			"updated_by": deletedBy,
		}).Error
}

func (r *CountryRepository) ExistsByCode(ctx context.Context, code string) (bool, error) {
	var count int64
	err := r.db.WithContext(ctx).
		Model(&Country{}).
		Where("UPPER(country_code) = UPPER(?) AND is_deleted = false", code).
		Count(&count).Error
	
	return count > 0, err
}

func (r *CountryRepository) GetActiveCount(ctx context.Context) (int, error) {
	var count int64
	err := r.db.WithContext(ctx).
		Model(&Country{}).
		Where("is_active = true AND is_deleted = false").
		Count(&count).Error
	
	return int(count), err
}

// Similar implementations for Region, Timezone, Language repositories...
// (Abbreviated for brevity - would be auto-generated)

// RegionRepository implements RegionRepositoryInterface
type RegionRepository struct {
	db *gorm.DB
}

func NewRegionRepository(db *gorm.DB) RegionRepositoryInterface {
	return &RegionRepository{db: db}
}

func (r *RegionRepository) Create(ctx context.Context, region *Region) error {
	now := time.Now()
	region.CreatedAt = &now
	region.UpdatedAt = &now
	return r.db.WithContext(ctx).Create(region).Error
}

func (r *RegionRepository) GetByCode(ctx context.Context, code string) (*Region, error) {
	var region Region
	err := r.db.WithContext(ctx).
		Where("region_code = ? AND is_deleted = false", code).
		First(&region).Error
	return &region, err
}

func (r *RegionRepository) GetChildren(ctx context.Context, parentID uuid.UUID) ([]*Region, error) {
	var regions []*Region
	err := r.db.WithContext(ctx).
		Where("parent_region_id = ? AND is_deleted = false AND is_active = true", parentID).
		Order("region_name").
		Find(&regions).Error
	return regions, err
}

// Auto-generated schema change detection
type SchemaChangeDetector struct {
	db *gorm.DB
}

func NewSchemaChangeDetector(db *gorm.DB) *SchemaChangeDetector {
	return &SchemaChangeDetector{db: db}
}

// DetectChanges compares current schema with expected LASANI structure
func (d *SchemaChangeDetector) DetectChanges(ctx context.Context, schema string) ([]SchemaChange, error) {
	var changes []SchemaChange
	
	// Query information_schema to detect new tables
	var tables []string
	err := d.db.WithContext(ctx).Raw(`
		SELECT table_name 
		FROM information_schema.tables 
		WHERE table_schema = ? 
		AND table_type = 'BASE TABLE'
		ORDER BY table_name
	`, schema).Scan(&tables).Error
	
	if err != nil {
		return nil, err
	}
	
	// Check each table for LASANI compliance
	for _, table := range tables {
		fieldCount, err := d.getFieldCount(ctx, schema, table)
		if err != nil {
			continue
		}
		
		// Expect 27 fields for LASANI compliance
		if fieldCount != 27 {
			changes = append(changes, SchemaChange{
				Type:        "LASANI_COMPLIANCE",
				Table:       table,
				Description: fmt.Sprintf("Table %s has %d fields, expected 27 for LASANI compliance", table, fieldCount),
				Action:      "REGENERATE_MODEL",
			})
		}
	}
	
	return changes, nil
}

func (d *SchemaChangeDetector) getFieldCount(ctx context.Context, schema, table string) (int, error) {
	var count int
	err := d.db.WithContext(ctx).Raw(`
		SELECT COUNT(*) 
		FROM information_schema.columns 
		WHERE table_schema = ? AND table_name = ?
	`, schema, table).Scan(&count).Error
	
	return count, err
}

type SchemaChange struct {
	Type        string `json:"type"`
	Table       string `json:"table"`
	Description string `json:"description"`
	Action      string `json:"action"`
}